<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>Guida — Tetris — pezzaliAPP</title>
  <meta name="theme-color" content="#0b5fff">
  <style>
    :root{--c1:#0f1320;--c2:#151b31;--c3:#0b5fff;--txt:#e9eef5}
    *{box-sizing:border-box} html,body{margin:0;height:100%}
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;background:var(--c1);color:var(--txt)}
    header{position:sticky;top:0;background:var(--c3);color:#fff;padding:12px 16px;box-shadow:0 2px 12px rgba(0,0,0,.25)}
    main{max-width:900px;margin:0 auto;padding:16px;display:grid;gap:16px}
    .card{background:var(--c2);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:14px}
    h1{font-size:1.2rem;margin:.2rem 0}
    h2{font-size:1.05rem;margin:.2rem 0 .6rem}
    code,kbd{background:rgba(255,255,255,.08);padding:2px 6px;border-radius:6px}
    .grid{display:grid;grid-template-columns:1fr 340px;gap:16px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    canvas{background:#12182a;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,.35);width:100%;height:auto}
    .muted{opacity:.9}
    .footer{opacity:.7;font-size:.9rem}
    a{color:#aacbff}
  </style>
</head>
<body>
  <header>
    <h1>Guida — Tetris — pezzaliAPP</h1>
  </header>
  <main>
    <section class="grid">
      <div class="card">
        <h2>Come si gioca</h2>
        <ul>
          <li><kbd>◀︎/▶︎</kbd> Muovi • <kbd>▼</kbd> Soft drop • <kbd>Space</kbd> Hard drop</li>
          <li><kbd>Z/X</kbd> Ruota • <kbd>C</kbd> Hold • <kbd>P</kbd> Pausa • <kbd>R</kbd> Restart</li>
        </ul>
        <p class="muted">Funziona offline, è installabile come app su iPhone/iPad/Android/PC/Mac.</p>
      </div>
      <div class="card">
        <h2>Demo</h2>
        <canvas id="demo" width="240" height="240" aria-label="Demo animata Tetris"></canvas>
        <p class="muted">Mini‑demo in Canvas: tetromino rotante con anteprima blocchi.</p>
      </div>
    </section>

    <section class="card">
      <h2>Installazione su iPhone</h2>
      <ol>
        <li>Apri la pagina con Safari.</li>
        <li>Tocca <strong>Condividi</strong> → <strong>Aggiungi a Home</strong>.</li>
        <li>Avvia l’app dalla Home per schermo intero.</li>
      </ol>
      <p class="muted">Se aggiorni l’app, chiudi e riapri con connessione oppure incrementa la costante <code>CACHE</code> nel <code>service-worker.js</code>.</p>
    </section>

    <section class="card">
      <h2>Licenza</h2>
      <p>MIT — © 2025 pezzaliAPP</p>
    </section>

    <p class="footer">Parte della collezione giochi pezzaliAPP.</p>
  </main>

<script>
// Mini-Tetris autoplay fedele (gioca per chiudere righe)
// Canvas: #demo 240x240 — griglia 10x20, tile 12px

const cvs = document.getElementById('demo');
const ctx = cvs.getContext('2d');
const W=10, H=20, TILE=12, offX=Math.floor((cvs.width-W*TILE)/2), offY=0;

const SHAPES = {
  I:[[0,1],[1,1],[2,1],[3,1]],
  J:[[0,0],[0,1],[1,1],[2,1]],
  L:[[2,0],[0,1],[1,1],[2,1]],
  O:[[1,0],[2,0],[1,1],[2,1]],
  S:[[1,0],[2,0],[0,1],[1,1]],
  Z:[[0,0],[1,0],[1,1],[2,1]],
  T:[[1,0],[0,1],[1,1],[2,1]],
};
const COLORS = {I:'#63e6ff',O:'#ffd43b',T:'#845ef7',S:'#51cf66',Z:'#ff6b6b',J:'#4dabf7',L:'#ffa94d'};

function rotCells(cells, r){
  // ruota in bounding 4x4
  return cells.map(([x,y])=>{
    let nx=x, ny=y;
    for(let i=0;i<r;i++){ const tx=3-ny, ty=nx; nx=tx; ny=ty; }
    return [nx,ny];
  });
}
function newPiece(t){ return {t, r:0, x:3, y:-1}; }

class Bag7{
  constructor(){ this.b=[]; }
  next(){ if(!this.b.length) this.b=['I','J','L','O','S','T','Z'].sort(()=>Math.random()-0.5); return this.b.pop(); }
}

let board = Array.from({length:H},()=>Array(W).fill(0));
const bag = new Bag7();
let curr = newPiece(bag.next());
let nextT = bag.next();
let over=false, clearedTotal=0;

function valid(p, dx=0, dy=0, rr=0){
  const cells = rotCells(SHAPES[p.t], (p.r+rr)&3);
  for(const [x,y] of cells){
    const nx = p.x + x + dx;
    const ny = p.y + y + dy;
    if (nx<0 || nx>=W || ny>=H) return false;
    if (ny>=0 && board[ny][nx]) return false;
  }
  return true;
}

function dropPos(p){
  const q = {...p};
  while(valid(q,0,1,0)) q.y++;
  return q;
}
function place(q){
  for(const [x,y] of rotCells(SHAPES[q.t], q.r)){
    const gx=q.x+x, gy=q.y+y;
    if (gy>=0) board[gy][gx]=q.t;
  }
  // clear lines
  let cleared=0;
  for(let y=H-1;y>=0;y--){
    if (board[y].every(v=>v)){ board.splice(y,1); board.unshift(Array(W).fill(0)); cleared++; y++; }
  }
  clearedTotal+=cleared;
  // next piece
  curr = newPiece(nextT);
  nextT = bag.next();
  if (!valid(curr,0,0,0)) over=true;
  return cleared;
}

// Heuristica: massimizza linee, minimizza buchi/altezza/bumpiness
function evalBoard(sim){
  // aggregate height, holes, bumpiness
  let heights = Array(W).fill(0), holes=0;
  for(let x=0;x<W;x++){
    let hFound=false;
    for(let y=0;y<H;y++){
      if (sim[y][x]){
        if (!hFound){ heights[x]=H-y; hFound=true; }
      }else if(hFound){ holes++; }
    }
  }
  let aggH = heights.reduce((a,b)=>a+b,0);
  let bump=0; for(let i=0;i<W-1;i++) bump += Math.abs(heights[i]-heights[i+1]);
  return {aggH, holes, bump};
}

function simulatePlace(p){
  // clona board
  const sim = board.map(row=>row.slice());
  for(const [x,y] of rotCells(SHAPES[p.t], p.r)){
    const gx=p.x+x, gy=p.y+y;
    if (gy>=0) sim[gy][gx]=p.t;
  }
  // conta linee
  let lines=0;
  for(let y=0;y<H;y++) if (sim[y].every(v=>v)) lines++;
  const {aggH, holes, bump} = evalBoard(sim);
  // punteggi (tuning leggero)
  const score =  (lines*120)
               - (holes*55)
               - (aggH*1.1)
               - (bump*1.6);
  return {score, lines};
}

function bestMove(piece){
  let best=null;
  for(let r=0;r<4;r++){
    // larghezza del pezzo in questa rotazione
    const cells = rotCells(SHAPES[piece.t], r);
    const minx = Math.min(...cells.map(c=>c[0]));
    const maxx = Math.max(...cells.map(c=>c[0]));
    const left = -minx, right = W-1 - maxx;
    for(let x=left; x<=right; x++){
      const cand = {t:piece.t, r, x, y:-1};
      // fai scendere
      if (!valid(cand,0,0,0)) continue;
      const dropped = dropPos(cand);
      const {score, lines} = simulatePlace(dropped);
      if (!best || score>best.score || (score===best.score && lines>(best.lines||0))){
        best = {move:dropped, score, lines};
      }
    }
  }
  return best ? best.move : dropPos(piece); // fallback
}

// Animazione: gioca automaticamente una posa ogni tot ms
let last=0, stepMs=320; // velocità autoplay (riduci per più rapido)
function loop(ts){
  draw();
  if (over){ requestAnimationFrame(loop); return; }
  if (ts-last > stepMs){
    last = ts;
    // scegli la miglior mossa per il pezzo corrente
    const move = bestMove(curr);
    // piccola animazione di caduta “a scatti” per chiarezza
    if (curr.x!==move.x || curr.r!==move.r || curr.y!==move.y){
      // muovi verso target
      if (curr.r!==move.r && valid(curr,0,0,(move.r - curr.r + 4)&3)) curr.r = move.r;
      else if (curr.x<move.x && valid(curr,1,0,0)) curr.x++;
      else if (curr.x>move.x && valid(curr,-1,0,0)) curr.x--;
      else if (valid(curr,0,1,0)) curr.y++;
      else place(curr); // lock se tocca
    } else {
      place(move); // atterra e piazza
    }
  }
  requestAnimationFrame(loop);
}

// Disegno
function draw(){
  // sfondo + griglia
  ctx.fillStyle='#0e1429'; ctx.fillRect(0,0,cvs.width,cvs.height);
  ctx.strokeStyle='rgba(255,255,255,.06)';
  for(let x=0;x<=W;x++){ ctx.beginPath(); ctx.moveTo(offX+x*TILE,offY); ctx.lineTo(offX+x*TILE,offY+H*TILE); ctx.stroke(); }
  for(let y=0;y<=H;y++){ ctx.beginPath(); ctx.moveTo(offX,offY+y*TILE); ctx.lineTo(offX+W*TILE,offY+y*TILE); ctx.stroke(); }

  // blocchi fissi
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const t=board[y][x]; if(t) drawTile(x,y,COLORS[t],1);
  }
  // ghost
  const g={...curr}; while(valid(g,0,1,0)) g.y++;
  drawPiece(g, true);
  // corrente
  drawPiece(curr, false);

  // badge info
  ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(8,8,90,26);
  ctx.fillStyle='#e9eef5'; ctx.font='12px system-ui';
  ctx.fillText(`Lines: ${clearedTotal}`, 14, 25);
}
function drawPiece(p, ghost){
  const cells = rotCells(SHAPES[p.t], p.r);
  for(const [x,y] of cells){
    const gx=p.x+x, gy=p.y+y; if(gy<0) continue;
    drawTile(gx,gy, COLORS[p.t], ghost?0.25:1);
  }
}
function drawTile(x,y,color,a){
  const px=offX+x*TILE, py=offY+y*TILE;
  ctx.save(); ctx.globalAlpha=a; ctx.fillStyle=color;
  ctx.fillRect(px+1,py+1,TILE-2,TILE-2);
  ctx.globalAlpha=Math.min(a,.22); ctx.fillStyle='#fff';
  ctx.fillRect(px+1,py+1,TILE-2,4);
  ctx.restore();
}

requestAnimationFrame(loop);
</script>
</body>
</html>
